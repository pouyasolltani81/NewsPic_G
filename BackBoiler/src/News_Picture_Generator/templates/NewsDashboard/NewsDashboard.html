{% extends "ui/user_base.html" %}
{% load i18n %}

{% block title %}NewsDashboard –  UI{% endblock %}
{% block page_heading %}NewsDashboard{% endblock %}

{% block extra_css %}
  {{ block.super }}
{% endblock %}

{% block content %}



  <div id="main-content" class='z-10'>

    <!-- Loading overlay -->
    {% if needs_translation %}
    <div id="translation-overlay" class="translation-overlay">
        <div class="translation-progress">
            <h3>Translating content...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <p class="progress-text">
                <span id="progress-current">0</span> / <span id="progress-total">0</span> items translated
            </p>
        </div>
    </div>
    {% endif %}


    {# ─────────────────────── DASHBOARD TAB ─────────────────────── #}
    {% include "./partials/dashboard_section.html" %}

  
    
     {# ─────────────────────── MESSAGES TAB ─────────────────────── #}
    {% include "./partials/messages_section.html" %}

   
  </div>
{% endblock %}

{% block extra_js %}
  {{ block.super }}
  <script>

  const navItems = [
  { key: '1', section: "dashboard", label: "{{ _('Dashboard') }}", icon: "layout-dashboard", active: true },
  { key: '2', section: "messages", label: "{{ _('Messages') }}", icon: "mails" },


];


    const contentSections = {
      dashboard: document.getElementById('dashboard-content'),
      messages: document.getElementById('messages-content'),

    };

    const nav = new NavigationMain('navigationMain', navItems, contentSections);
    
    window.addEventListener('DOMContentLoaded', () => {
      window.nav = nav;
 
    
    });
</script>


<script>

  {% include "./partials/messages.js" %}

</script>


<script>

      // Modal elements
      const modal = document.getElementById('generateModal');
      const generateBtn = document.getElementById('generateBtn');
      const closeModal = document.getElementById('closeModal');
      const cancelBtn = document.getElementById('cancelBtn');
      const generateForm = document.getElementById('generateForm');
      const generateText = document.getElementById('generateText');
      const generateSpinner = document.getElementById('generateSpinner');
      
      // Filter functionality
      const imageFilter = document.getElementById('imageFilter');
      const imageCards = document.querySelectorAll('.image-card');
      
      // Show/hide modal
      generateBtn.addEventListener('click', () => {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
      });
      
      closeModal.addEventListener('click', () => {
          modal.classList.add('hidden');
          modal.classList.remove('flex');
      });
      
      cancelBtn.addEventListener('click', () => {
          modal.classList.add('hidden');
          modal.classList.remove('flex');
      });
      
      // Close modal on outside click
      modal.addEventListener('click', (e) => {
          if (e.target === modal) {
              modal.classList.add('hidden');
              modal.classList.remove('flex');
          }
      });
      
      // Handle form submission
      generateForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          // Show loading state
          generateText.textContent = 'Generating...';
          generateSpinner.classList.remove('hidden');
          generateBtn.disabled = true;
          
          const formData = new FormData(generateForm);
          const data = {
              prompt: formData.get('prompt'),
              width: parseInt(formData.get('width')),
              height: parseInt(formData.get('height')),
              negative_prompt: formData.get('negative_prompt'),
              seed: parseInt(formData.get('seed')),
              steps: parseInt(formData.get('steps')),
              guidance_scale: parseFloat(formData.get('guidance_scale'))
          };
          
          try {
              const response = await fetch('/News_Picture_Generator/custom-images/generate/', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-CSRFToken': getCookie('csrftoken')
                  },
                  body: JSON.stringify(data)
              });
              
              if (response.ok) {
                  const result = await response.json();
                  // Show success message
                  alert('Image generated successfully!');
                  // Reload page to show new image
                  window.location.reload();
              } else {
                  throw new Error('Generation failed');
              }
          } catch (error) {
              alert('Error generating image. Please try again.');
              console.error('Error:', error);
          } finally {
              // Reset loading state
              generateText.textContent = 'Generate';
              generateSpinner.classList.add('hidden');
              generateBtn.disabled = false;
          }
      });
      
      // Filter functionality
      imageFilter.addEventListener('change', (e) => {
          const filterValue = e.target.value.toLowerCase();
          
          imageCards.forEach(card => {
              const title = card.dataset.title;
              const prompt = card.dataset.prompt;
              
              if (filterValue === 'all') {
                  card.style.display = '';
    
                } else if (filterValue === 'recent') {
                  // You'll need to add a data-date attribute to cards in the template
                  // For now, just show all
                  card.style.display = '';
              } else {
                  // Filter by keyword in title or prompt
                  if (title.includes(filterValue) || prompt.includes(filterValue)) {
                      card.style.display = '';
                  } else {
                      card.style.display = 'none';
                  }
              }
          });
      });
      
      // Helper function to get CSRF token
      function getCookie(name) {
          let cookieValue = null;
          if (document.cookie && document.cookie !== '') {
              const cookies = document.cookie.split(';');
              for (let i = 0; i < cookies.length; i++) {
                  const cookie = cookies[i].trim();
                  if (cookie.substring(0, name.length + 1) === (name + '=')) {
                      cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                      break;
                  }
              }
          }
          return cookieValue;
      }
   
    </script>


    
<style>
.translation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.translation-progress {
    background: white;
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    min-width: 300px;
}

.progress-bar-container {
    width: 100%;
    height: 20px;
    background: #f0f0f0;
    border-radius: 10px;
    margin: 20px 0;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    background: #4CAF50;
    width: 0%;
    transition: width 0.3s ease;
}

.progress-text {
    font-size: 14px;
    color: #666;
}

.news-title {
    transition: opacity 0.3s ease;
}

.news-title.translating {
    opacity: 0.5;
}
</style>

<script>
{% if needs_translation %}
document.addEventListener('DOMContentLoaded', function() {
    const targetLang = '{{ current_lang }}';
    const overlay = document.getElementById('translation-overlay');
    const progressBar = document.getElementById('progress-bar');
    const progressCurrent = document.getElementById('progress-current');
    const progressTotal = document.getElementById('progress-total');
    
    // Collect all items that need translation
    const items = [];
    document.querySelectorAll('.news-item').forEach(item => {
        const titleElement = item.querySelector('.news-title');
        const originalTitle = titleElement.dataset.originalTitle;
        if (originalTitle) {
            items.push({
                id: item.dataset.itemId,
                title: originalTitle,
                element: titleElement
            });
        }
    });
    
    progressTotal.textContent = items.length;
    
    // Function to translate a single item
    async function translateSingle(item) {
        console.log('Translating:', item.title, 'to', targetLang);
        
        try {
            const response = await fetch('http://79.175.177.113:19800/Translate/translate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    text: item.title,
                    target_lang: targetLang,
                    source_lang: ''  // auto-detect
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                console.log('Translation response:', data);
                
                if (data.success && data.data && data.data.translated_text) {
                    return {
                        id: item.id,
                        translated_title: data.data.translated_text
                    };
                } else if (data.success && data.translated_text) {
                    // Handle flat response structure
                    return {
                        id: item.id,
                        translated_title: data.translated_text
                    };
                }
            }
            
            console.error('Translation failed for:', item.title);
            return {
                id: item.id,
                translated_title: item.title  // Return original on failure
            };
            
        } catch (error) {
            console.error('Translation error:', error);
            return {
                id: item.id,
                translated_title: item.title  // Return original on error
            };
        }
    }
    
    // Function to translate items in batches (but calling single API)
    async function translateBatch(batch) {
        console.log('Processing batch of', batch.length, 'items');
        
        // Translate all items in the batch concurrently
        const translationPromises = batch.map(item => translateSingle(item));
        const translations = await Promise.all(translationPromises);
        
        return translations;
    }
    
    // Translate items progressively
    async function translateAll() {
        const batchSize = 3; // Process 3 items at a time
        let translated = 0;
        
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            
            // Add translating class
            batch.forEach(item => item.element.classList.add('translating'));
            
            const translations = await translateBatch(batch);
            console.log('Batch translations:', translations);
            
            // Apply translations
            translations.forEach(trans => {
                const item = items.find(it => it.id === trans.id);
                if (item) {
                    item.element.textContent = trans.translated_title;
                    item.element.classList.remove('translating');
                    translated++;
                    
                    // Update progress
                    progressCurrent.textContent = translated;
                    progressBar.style.width = (translated / items.length * 100) + '%';
                }
            });
            
            // Small delay between batches to avoid overwhelming the server
            if (i + batchSize < items.length) {
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }
        
        // Hide overlay when done
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 500);
    }
    
    // Alternative: Sequential translation (one at a time)
    async function translateSequentially() {
        let translated = 0;
        
        for (const item of items) {
            // Add translating class
            item.element.classList.add('translating');
            
            // Translate single item
            const translation = await translateSingle(item);
            
            // Apply translation
            item.element.textContent = translation.translated_title;
            item.element.classList.remove('translating');
            translated++;
            
            // Update progress
            progressCurrent.textContent = translated;
            progressBar.style.width = (translated / items.length * 100) + '%';
            
            // Small delay to avoid overwhelming the server
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Hide overlay when done
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 500);
    }
    
    // Start translation
    if (items.length > 0) {
        // Choose one of these methods:
        
        // Method 1: Batch processing (faster, processes multiple items concurrently)
        translateAll();
        
        // Method 2: Sequential processing (slower, but easier on the server)
        // translateSequentially();
    } else {
        overlay.style.display = 'none';
    }
});
{% endif %}
</script>

{% endblock %}
